---
description: "Comprehensive guide for creating Aiexec components with best practices, examples, and advanced patterns."
globs:
  - "api/**/components/**/*.py"
  - "api/base/aiexec/components/**/*.py"
alwaysApply: false
---

# Rule: Aiexec Component Development Guide

## Purpose
This guide provides comprehensive instructions for creating robust, maintainable, and user-friendly Aiexec components. It covers everything from basic setup to advanced patterns and best practices.

---

## 1. Component Planning

### 1.1 Requirements Gathering
Before implementation, gather these details:

#### Core Information
- **Component Name**:
  - Use PascalCase (e.g., `ImageProcessor`, `DataValidator`)
  - Be specific and descriptive
  - Suffix with `Component` in code (e.g., `ImageProcessorComponent`)

- **Description**:
  - Start with a verb (e.g., "Processes images...", "Validates data...")
  - Be concise but comprehensive
  - Mention any dependencies or requirements

#### Inputs/Outputs
- **Inputs**:
  - List all required and optional parameters
  - Specify types (String, Number, Boolean, File, etc.)
  - Define default values where applicable
  - Add validation rules

- **Outputs**:
  - Define the output structure
  - Include success/failure states
  - Document any side effects

#### Category
Choose an appropriate category from existing ones in `aiexec/api/base/aiexec/components` or propose a new one if needed. Common categories include:
- `data_processing/`
- `ai_models/`
- `utilities/`
- `io/`
- `apis/`

### 1.2 Design Considerations
- **Idempotency**: Can the component be safely retried?
- **Performance**: Are there any heavy operations that need optimization?
- **Error Handling**: What are the possible failure modes?
- **Security**: Does it handle sensitive data? Any authentication needed?
- **Testing**: What are the key test cases?

## 2. Real-world Component Examples

### 2.1 Data Processing Component
```python
# components/data_processing/text_cleaner.py
from typing import Dict, Any, Optional
from aiexec.components.base import Component
from aiexec.components.fields import StringInput, Output, BooleanInput
import re

class TextCleanerComponent(Component):
    """
    Cleans and normalizes text input by removing extra whitespace,
    special characters, and optionally converting to lowercase.

    Example Usage:
    - Clean user input before processing
    - Normalize text for NLP tasks
    - Prepare text for storage or analysis
    """
    display_name = "Text Cleaner"
    description = "Cleans and normalizes text input by removing extra whitespace and special characters."
    icon = "type"
    name = "TextCleaner"
    version = "1.0.0"

    inputs = [
        StringInput(
            name="text",
            display_name="Input Text",
            info="The text to be cleaned",
            required=True
        ),
        BooleanInput(
            name="to_lowercase",
            display_name="Convert to Lowercase",
            info="Whether to convert text to lowercase",
            default=True
        ),
        BooleanInput(
            name="remove_special_chars",
            display_name="Remove Special Characters",
            info="Remove non-alphanumeric characters",
            default=True
        )
    ]

    outputs = [
        Output(
            name="cleaned_text",
            field=StringInput(
                name="cleaned_text",
                display_name="Cleaned Text",
                info="The cleaned and normalized text output"
            )
        )
    ]

    async def run(self) -> Dict[str, Any]:
        text = self.get_input("text")
        to_lowercase = self.get_input("to_lowercase")
        remove_special = self.get_input("remove_special_chars")

        # Clean whitespace
        cleaned = " ".join(text.split())

        # Convert to lowercase if needed
        if to_lowercase:
            cleaned = cleaned.lower()

        # Remove special characters if needed
        if remove_special:
            cleaned = re.sub(r'[^\w\s]', '', cleaned)

        return {"cleaned_text": cleaned}
```

### 2.2 API Integration Component
```python
# components/apis/weather_api.py
from typing import Dict, Any, Optional
import httpx
from aiexec.components.base import Component
from aiexec.components.fields import StringInput, NumberInput, Output, DropdownInput

class WeatherAPIClient(Component):
    """
    Fetches weather data from a public weather API.

    This component demonstrates:
    - Making HTTP requests to external APIs
    - Handling API keys and authentication
    - Processing and transforming API responses
    - Error handling for external services
    """
    display_name = "Weather API"
    description = "Fetches current weather data for a specified location"
    icon = "cloud"
    name = "WeatherAPI"
    version = "1.0.0"

    inputs = [
        StringInput(
            name="api_key",
            display_name="API Key",
            info="Your OpenWeatherMap API key",
            required=True,
            password=True
        ),
        StringInput(
            name="city",
            display_name="City",
            info="Name of the city",
            required=True
        ),
        StringInput(
            name="country_code",
            display_name="Country Code",
            info="ISO 3166 country code (e.g., 'us', 'gb')",
            default="us"
        ),
        DropdownInput(
            name="units",
            display_name="Units",
            info="Units of measurement",
            options=["metric", "imperial", "standard"],
            default="metric"
        )
    ]

    outputs = [
        Output(
            name="weather_data",
            field=StringInput(
                name="weather_data",
                display_name="Weather Data",
                info="Formatted weather information"
            )
        ),
        Output(
            name="temperature",
            field=NumberInput(
                name="temperature",
                display_name="Temperature",
                info="Current temperature"
            )
        )
    ]

    async def run(self) -> Dict[str, Any]:
        base_url = "https://api.openweathermap.org/data/2.5/weather"
        params = {
            "q": f"{self.get_input('city')},{self.get_input('country_code')}",
            "appid": self.get_input("api_key"),
            "units": self.get_input("units")
        }

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(base_url, params=params)
                response.raise_for_status()
                data = response.json()

                return {
                    "weather_data": (
                        f"Weather in {data['name']}: {data['weather'][0]['description']}"
                        f"\nTemperature: {data['main']['temp']}Â°C"
                        f"\nHumidity: {data['main']['humidity']}%"
                        f"\nWind: {data['wind']['speed']} m/s"
                    ),
                    "temperature": data['main']['temp']
                }

        except httpx.HTTPStatusError as e:
            if e.response.status_code == 401:
                raise ValueError("Invalid API key")
            elif e.response.status_code == 404:
                raise ValueError("City not found")
            else:
                raise Exception(f"Weather API error: {str(e)}")
        except Exception as e:
            raise Exception(f"Failed to fetch weather data: {str(e)}")
```

### 2.3 AI Model Integration Component
```python
# components/ai_models/sentiment_analyzer.py
from typing import Dict, Any, List
from aiexec.components.base import Component
from aiexec.components.fields import StringInput, Output, DropdownInput
from transformers import pipeline, AutoModelForSequenceClassification, AutoTokenizer
import torch

class SentimentAnalyzerComponent(Component):
    """
    Analyzes sentiment of input text using a pre-trained model.

    This component demonstrates:
    - Loading and using Hugging Face models
    - GPU acceleration when available
    - Batching for improved performance
    - Model configuration options
    """
    display_name = "Sentiment Analyzer"
    description = "Analyzes sentiment of text using a pre-trained model"
    icon = "smile"
    name = "SentimentAnalyzer"
    version = "1.0.1"

    # Model cache to avoid reloading
    _model = None
    _tokenizer = None

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.device = 0 if torch.cuda.is_available() else -1  # Use GPU if available

    @classmethod
    def get_model(cls):
        """Singleton pattern to load model only once."""
        if cls._model is None or cls._tokenizer is None:
            model_name = "distilbert-base-uncased-finetuned-sst-2-english"
            cls._tokenizer = AutoTokenizer.from_pretrained(model_name)
            cls._model = AutoModelForSequenceClassification.from_pretrained(model_name)
        return cls._model, cls._tokenizer

    inputs = [
        StringInput(
            name="text",
            display_name="Input Text",
            info="Text to analyze",
            required=True
        ),
        DropdownInput(
            name="return_all_scores",
            display_name="Return All Scores",
            info="Return scores for all labels or just the top one",
            options=["true", "false"],
            default="false"
        )
    ]

    outputs = [
        Output(
            name="sentiment",
            field=StringInput(
                name="sentiment",
                display_name="Sentiment",
                info="Analyzed sentiment result"
            )
        ),
        Output(
            name="scores",
            field=StringInput(
                name="scores",
                display_name="Scores",
                info="Detailed sentiment scores"
            )
        )
    ]

    async def run(self) -> Dict[str, Any]:
        model, tokenizer = self.get_model()
        classifier = pipeline(
            "sentiment-analysis",
            model=model,
            tokenizer=tokenizer,
            device=self.device
        )

        result = classifier(
            self.get_input("text"),
            return_all_scores=(self.get_input("return_all_scores") == "true")
        )

        return {
            "sentiment": str(result[0]["label"] if isinstance(result[0], list) else result[0]["label"]),
            "scores": str(result)
        }
```

## 3. Component Implementation

### 2.1 Basic Structure
```python
from typing import Dict, Any, Optional
from aiexec.components.base import Component
from aiexec.components.fields import (
    StringInput,
    NumberInput,
    BooleanInput,
    DropdownInput,
    Output,
    OutputField
)

class YourComponentName(Component):
    """
    Brief one-line description.

    Detailed description including:
    - Purpose and functionality
    - Input/Output specifications
    - Example usage
    - Any important notes or warnings
    """
    # Display information (shown in UI)
    display_name = "User-Friendly Name"
    description = "Detailed description of what the component does."
    icon = "icon-name"  # From Lucide icons or custom icons

    # Internal name (used in code)
    name = "YourComponentName"

    # Versioning
    version = "1.0.0"

    # Input definitions
    inputs = [
        StringInput(
            name="input_name",
            display_name="Input Label",
            info="Helpful description for users",
            required=True,
            default="default_value",
            # Additional validations
            min_length=1,
            max_length=100,
            regex=r"^[a-zA-Z0-9_]+$",
        ),
        # Add more inputs as needed
    ]

    # Output definitions
    outputs = [
        Output(
            name="output_name",
            fields=[
                OutputField(
                    name="result",
                    type="string",
                    description="Description of the output"
                ),
                # Add more output fields as needed
            ]
        )
    ]

    # Optional: Define component categories for organization
    categories = ["data_processing", "utilities"]

    # Main execution method
    async def execute(self, **inputs) -> Dict[str, Any]:
        """
        Main execution logic for the component.

        Args:
            **inputs: Dictionary of input values

        Returns:
            Dict containing output values

        Raises:
            ComponentError: For expected error cases
        """
        try:
            # Your implementation here
            result = self._process_inputs(inputs)

            # Return outputs matching the defined schema
            return {
                "output_name": {
                    "result": result,
                    "status": "success",
                    "metadata": {}
                }
            }

        except Exception as e:
            # Log error and re-raise with context
            self.logger.error(f"Error in {self.name}: {str(e)}")
            raise ComponentError(
                message="Failed to process component",
                details=str(e),
                error_type="processing_error"
            )

    # Helper methods (prefixed with _)
    def _process_inputs(self, inputs: Dict[str, Any]) -> Any:
        """Process and validate inputs."""
        # Input processing logic here
        return processed_result
```

### 2.2 Key Implementation Guidelines

#### Input/Output Definitions
- Use appropriate input types from `aiexec.components.fields`
- Always provide clear, helpful descriptions
- Set sensible defaults when possible
- Document any constraints or validations

#### Error Handling
- Use specific exception types for different error cases
- Provide meaningful error messages
- Include error codes for programmatic handling
- Log detailed error information

#### Logging
- Use the built-in logger: `self.logger`
- Log at appropriate levels (debug, info, warning, error)
- Include relevant context in log messages
- Avoid logging sensitive information

## 3. Advanced Patterns

### 3.1 Stateful Components
```python
class StatefulComponent(Component):
    # ... other definitions ...

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._state = {}

    async def execute(self, **inputs):
        # Access and update state
        if "counter" not in self._state:
            self._state["counter"] = 0
        self._state["counter"] += 1

        return {"count": self._state["counter"]}
```

### 3.2 Asynchronous Operations
```python
class AsyncAPICallComponent(Component):
    # ... other definitions ...

    async def execute(self, **inputs):
        async with aiohttp.ClientSession() as session:
            async with session.get("https://api.example.com/data") as response:
                data = await response.json()
                return {"result": data}
```

### 3.3 File Handling
```python
class FileProcessorComponent(Component):
    # ... other definitions ...

    inputs = [
        FileInput(
            name="input_file",
            display_name="Input File",
            info="File to process",
            required=True,
            file_types=["txt", "csv", "json"]
        )
    ]

    async def execute(self, input_file: bytes, **kwargs):
        # Process file content
        result = self._process_file(input_file)
        return {"processed_data": result}
```

## 4. Complete Examples

### 4.1 Conditional Router Component
```python
class ConditionalRouterComponent(Component):
    """
    Routes an input message to different outputs based on conditions.

    This component evaluates input conditions and routes the data to the
    appropriate output based on the first matching condition.
    """
    display_name = "Conditional Router"
    description = "Routes data to different outputs based on defined conditions."
    icon = "route"
    name = "ConditionalRouter"
    version = "1.0.0"

    inputs = [
        StringInput(
            name="input_value",
            display_name="Input Value",
            info="Value to evaluate against conditions",
            required=True
        ),
        ListInput(
            name="conditions",
            display_name="Conditions",
            info="List of conditions to evaluate",
            item_type="object",
            schema={
                "condition": {"type": "string"},
                "output": {"type": "string"}
            },
            default=[]
        ),
        StringInput(
            name="default_output",
            display_name="Default Output",
            info="Output to use if no conditions match",
            default="default"
        )
    ]

    outputs = [
        Output(
            name="output",
            fields=[
                OutputField(
                    name="matched_condition",
                    type="string",
                    description="The condition that was matched"
                ),
                OutputField(
                    name="output_value",
                    type="string",
                    description="The output value for the matched condition"
                )
            ]
        )
    ]

    async def execute(self, input_value: str, conditions: list, default_output: str, **kwargs):
        """Evaluate conditions and route the input accordingly."""
        try:
            for condition in conditions:
                if self._evaluate_condition(input_value, condition["condition"]):
                    return {
                        "output": {
                            "matched_condition": condition["condition"],
                            "output_value": condition["output"]
                        }
                    }

            return {
                "output": {
                    "matched_condition": "default",
                    "output_value": default_output
                }
            }

        except Exception as e:
            self.logger.error(f"Error in ConditionalRouter: {str(e)}")
            raise ComponentError(
                message="Failed to evaluate conditions",
                details=str(e),
                error_type="evaluation_error"
            )

    def _evaluate_condition(self, value: str, condition: str) -> bool:
        """Evaluate a single condition."""
        # Implement condition evaluation logic
        # This is a simple equality check, but could be extended
        return value == condition
```

### 4.2 Current Date Component
```python
from datetime import datetime
import pytz

class CurrentDateComponent(Component):
    """
    Returns the current date and time in the specified timezone.

    This component provides the current date and time in various formats
    and timezones for use in workflows.
    """
    display_name = "Current Date & Time"
    description = "Gets the current date and time in the specified timezone."
    icon = "clock"
    name = "CurrentDate"
    version = "1.0.0"

    inputs = [
        DropdownInput(
            name="timezone",
            display_name="Timezone",
            info="Timezone to get current time for",
            options=[
                {"label": "UTC", "value": "UTC"},
                {"label": "Local Time", "value": "local"},
                # Add more timezones as needed
            ],
            default="UTC",
            required=True
        ),
        StringInput(
            name="format",
            display_name="Date Format",
            info="Python strftime format string (default: ISO format)",
            default="%Y-%m-%dT%H:%M:%S%z",
            required=False
        )
    ]

    outputs = [
        Output(
            name="datetime",
            fields=[
                OutputField(
                    name="iso_format",
                    type="string",
                    description="ISO 8601 formatted datetime"
                ),
                OutputField(
                    name="formatted",
                    type="string",
                    description="Formatted datetime string"
                ),
                OutputField(
                    name="timestamp",
                    type="number",
                    description="Unix timestamp"
                ),
                OutputField(
                    name="timezone",
                    type="string",
                    description="Timezone used for the datetime"
                )
            ]
        )
    ]

    async def execute(self, timezone: str, format: str, **kwargs):
        """Get current datetime in the specified timezone and format."""
        try:
            # Get current time in UTC
            now = datetime.utcnow().replace(tzinfo=pytz.utc)

            # Convert to target timezone
            if timezone.lower() != "utc":
                try:
                    tz = pytz.timezone(timezone)
                    now = now.astimezone(tz)
                except pytz.exceptions.UnknownTimeZoneError:
                    self.logger.warning(f"Unknown timezone: {timezone}, using UTC")
                    timezone = "UTC"

            # Format the datetime
            formatted = now.strftime(format)

            return {
                "datetime": {
                    "iso_format": now.isoformat(),
                    "formatted": formatted,
                    "timestamp": now.timestamp(),
                    "timezone": timezone
                }
            }

        except Exception as e:
            self.logger.error(f"Error in CurrentDate: {str(e)}")
            raise ComponentError(
                message="Failed to get current date",
                details=str(e),
                error_type="datetime_error"
            )
```

## 5. Best Practices

### 5.1 Code Organization
- Keep components focused on a single responsibility
- Split complex logic into helper methods
- Use type hints for better IDE support and documentation
- Document public methods and classes with docstrings
- Keep imports organized and grouped (standard library, third-party, local)

### 5.2 Error Handling
- Always validate inputs before processing
- Provide clear, actionable error messages
- Use specific exception types for different error cases
- Include error codes for programmatic handling
- Log errors with sufficient context for debugging

### 5.3 Performance
- Cache expensive operations when possible
- Use async/await for I/O-bound operations
- Implement pagination for large datasets
- Consider adding rate limiting for external API calls
- Profile and optimize critical paths

### 5.4 Security
- Sanitize all user inputs
- Use parameterized queries for database operations
- Implement proper authentication and authorization
- Never log sensitive information
- Follow the principle of least privilege

### 5.5 Testing
- Write unit tests for all public methods
- Test edge cases and error conditions
- Include integration tests for component workflows
- Mock external dependencies in tests
- Test with different input types and sizes

### 5.6 Documentation
- Document all public APIs
- Include examples in docstrings
- Document any side effects or limitations
- Keep the README up to date
- Include usage examples

### 5.7 UI/UX
- Use clear, consistent naming
- Provide helpful tooltips and descriptions
- Group related inputs together
- Set sensible defaults
- Validate inputs with helpful error messages

## 6. Testing Guidelines

### 6.1 Unit Tests
- Test individual methods in isolation
- Mock external dependencies
- Test both success and error cases
- Test edge cases and boundary conditions

### 6.2 Integration Tests
- Test component interactions
- Test with real dependencies when possible
- Test error handling and recovery
- Test performance with realistic loads

### 6.3 Test Structure
```python
import pytest
from unittest.mock import patch, MagicMock
from your_module import YourComponent

class TestYourComponent:
    @pytest.fixture
    def component(self):
        return YourComponent()

    def test_success_case(self, component):
        # Test successful execution
        result = component.execute(input1="test")
        assert result == expected_output

    def test_error_handling(self, component):
        # Test error conditions
        with pytest.raises(ComponentError):
            component.execute(input1="invalid")
```

## 7. Performance Optimization

### 7.1 Caching
- Cache expensive computations
- Use memoization for pure functions
- Consider time-based invalidation
- Be mindful of memory usage

### 7.2 Asynchronous Processing
- Use async/await for I/O operations
- Implement proper concurrency controls
- Handle backpressure appropriately
- Consider using asyncio.gather for parallel operations

### 7.3 Memory Management
- Use generators for large datasets
- Close resources properly
- Monitor memory usage
- Consider streaming for large files

## 8. Security Considerations

### 8.1 Input Validation
- Validate all inputs
- Sanitize user-provided data
- Use allowlists over blocklists
- Implement proper type checking

### 8.2 Authentication & Authorization
- Verify user permissions
- Implement proper session management
- Use secure password hashing
- Follow OWASP guidelines

### 8.3 Data Protection
- Encrypt sensitive data
- Implement proper key management
- Follow data minimization principles
- Comply with relevant regulations (GDPR, CCPA, etc.)

## 9. Deployment & Monitoring

### 9.1 Logging
- Use structured logging
- Include request IDs for tracing
- Log at appropriate levels
- Include sufficient context

### 9.2 Metrics
- Track key performance indicators
- Monitor error rates
- Set up alerts for critical issues
- Use distributed tracing

### 9.3 Health Checks
- Implement readiness/liveness endpoints
- Monitor dependencies
- Set up automated recovery
- Test failure scenarios

## 10. Maintenance

### 10.1 Versioning
- Follow semantic versioning
- Maintain changelog
- Document breaking changes
- Provide migration guides

### 10.2 Deprecation
- Mark deprecated features
- Provide clear upgrade paths
- Remove deprecated code in major versions
- Document alternatives

## Checklist for Creating a Component

### Planning
- [ ] Define clear requirements and specifications
- [ ] Design the component interface
- [ ] Identify potential edge cases and error conditions
- [ ] Plan for testing and validation

### Implementation
- [ ] Create the component class with proper inheritance
- [ ] Define inputs and outputs with proper types and validation
- [ ] Implement the core logic
- [ ] Add error handling and logging
- [ ] Write docstrings and comments

### Testing
- [ ] Write unit tests
- [ ] Test edge cases
- [ ] Perform integration testing
- [ ] Test error conditions
- [ ] Verify performance characteristics

### Documentation
- [ ] Document the component's purpose and usage
- [ ] Provide examples
- [ ] Document any limitations or known issues
- [ ] Update the README

### Review
- [ ] Perform code review
- [ ] Verify security considerations
- [ ] Check for performance bottlenecks
- [ ] Ensure proper error handling
- [ ] Verify test coverage

### Deployment
- [ ] Update version numbers
- [ ] Update changelog
- [ ] Deploy to staging
- [ ] Verify in staging environment
- [ ] Deploy to production

## Additional Resources

### Official Documentation
- [Aiexec Component API Reference](https://docs.aiexec.com/components)
- [Python Type Hints](https://docs.python.org/3/library/typing.html)
- [Pytest Documentation](https://docs.pytest.org/)

### Tools
- [Python Debugger (pdb)](https://docs.python.org/3/library/pdb.html)
- [Pylint](https://pylint.org/)
- [Black Code Formatter](https://black.readthedocs.io/)
- [Mypy](http://mypy-lang.org/)

### Further Reading
- [Clean Code in Python](https://www.oreilly.com/library/view/clean-code-in/9780136681770/)
- [Python Design Patterns](https://refactoring.guru/design-patterns/python)
- [Effective Python](https://effectivepython.com/)

---

This document provides a comprehensive guide to creating Aiexec components. Follow these guidelines to ensure your components are robust, maintainable, and user-friendly.
